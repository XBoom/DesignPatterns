# 原型模式
原型模式使对象能复制自身，并且暴露到接口中，使客户端面向接口编程时，不知道接口实际对象的情况下生成新的对象。

原型模式配合原型管理器使用，使得客户端在不知道具体类的情况下，通过接口管理器得到新的实例，并且包含部分预设定配置。


# 使用场景

如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同） 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新
对象，以达到节省创建时间的目的。

为何对象的创建成功比较大？
答：创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，
或者说对于大部分业务系统来说，这点时间完全是可以忽略的。
但是，

如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需
要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，就可以利
用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执
行这些耗时的操作

## 例子
假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜
索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用
于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建
立一个散列表索引

把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中
的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建
另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版
本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。

第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对
象只包含基本数据类型数据，没有引用对象为止。

第二种方法：先将对象序列化，然后再反序列化成新的对象。

第三种方法：先浅拷贝keys, 然后在需要更新的时候重新写入
HashMap 的深拷贝